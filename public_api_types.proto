syntax = "proto3";


enum RobotType {
    Unknown = 0;
    TripleOmniWheelLRDriver = 1;
    SteeringWheel3Module = 2;
    SteeringWheel4Module = 3;
    SteeringWheelSingleAModule = 4;
    SteeringWheelSingleBModule = 5;
    Mark1DiffBBDriver = 6;
    Mark1McnmBBDriver = 7;
    // Linear Lifts can not be force controlled.
    // If you want force controlled lifts, consider ForceControlledLift series.
    LinearLiftISVLDriver = 8;
    // Special Mode. Working purely as a can bus forwarder.
    PureForwardOnly = 100;
}

// Motor
message SingleMotorTarget{
    oneof target{
        double torque = 1;  // Nm
        double speed = 2;   // rad/s
        int64 position = 3; // encoder position
        bool brake = 4;     // No matter what mode, brake is always applied. Be aware that putting into brake mode might cause motor to lose position information.
    }
}

message MotorTargets {
    repeated SingleMotorTarget targets = 1;
}

enum MotorError{
    CommunicationError = 0;
    OverCurrent = 1;
    OverVoltage = 2;
    UnderVoltage = 3;
    MotorOverTemperature = 4;
    DriverOverTemperature = 5;
    GeneralError = 6;
}

message MotorStatus {
    // Nm
    double torque = 2; 
    // rad/s, clockwise is positive. Looking from output axis towards motor.
    // m/s, direction is not defined, for linear motor
    double speed = 3;
    // encoder position
    int64 position = 4;
    // Number of pulses per rotation
    // Number of pulses per meter, for linear motor
    uint32 pulse_per_rotation = 5;
    double wheel_radius = 6;

    repeated MotorError error = 7;
    SingleMotorTarget currnet_target = 8;

    optional float driver_temperature = 11;
    optional float motor_temperature = 12;
    // current suppiled voltage
    optional float voltage = 13;
}

// Base State
enum BaseState {
    Parked = 0;
    AlgrithmControl = 1;
    OvertakeSpeedControl = 2;
    OvertakeZeroResistanceControl = 3;
    EmergencyStop = 4;
}

enum EmergencyStopCategory {
    EmergencyStopButton = 0;
    MotorHasError = 1;
    BatteryFail = 2;
    GamepadTriggered = 3;
    UnknownEmergencyStopCategory = 4;
    APICommunicationTimeout = 5;
}

message ParkingStopDetail {
    string reason = 1;
    EmergencyStopCategory category = 2;
    bool is_remotely_clearable = 3;
}

message BaseStatus {
    BaseState state = 1;

    // Weather the API control is initialized.
    bool api_control_initialized = 2;
    float battery_voltage = 3;                  // V
    uint32 battery_thousandth = 4;              // 1/1000

    optional bool battery_charging = 10;
    optional ParkingStopDetail parking_stop_detail = 11;
    optional string warning_reason = 12;
}

message BaseCommand {
    oneof command{
        // Only after api_control_initialize is set, can the vehicle be controlled by the API.
        bool api_control_initialize = 1;
        // If currently has a clearable parking stop, the parking stop state will be cleared.
        bool clear_parking_stop = 2;
        // By sending this, will trigger a remote clearable parking stop with this detail. is_remotely_clearable MUST be true. 
        // WARNING: The ParkingStop will try to stop the vehicle, BUT MIGHT FAIL, in worst case even out of control.
        // DO NOT USE THIS AS EMERGENCY STOP. Use the physical emergency stop button in case of emergency.
        ParkingStopDetail trigger_parking_stop = 3;
        MotorTargets motor_targets = 4;
    }
}

// Read motor_status of APIUp to get current position
message LinearLiftStatus {
    bool calibrated = 1;
    bool calibrating = 2;
    int64 max_pos = 3;
}

message LinearLiftCommand {
    oneof command{
        bool calibrate = 1;
        // Encoder position.
        // You can calculate this from meters by multiplying with pulse_per_meter.
        int64 target_pos = 2;
        bool brake = 3;
    }
}
