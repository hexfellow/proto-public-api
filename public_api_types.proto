syntax = "proto3";

//////// Overall types //////////
enum RobotType {
    Unknown = 0;
    TripleOmniWheelLRDriver = 1;
    SteeringWheel3Module = 2;
    SteeringWheel4Module = 3;
    SteeringWheelSingleAModule = 4;
    SteeringWheelSingleBModule = 5;
    Mark1DiffBBDriver = 6;
    Mark1McnmBBDriver = 7;
    // Linear Lifts can not be force controlled.
    // If you want force controlled lifts, consider ForceControlledLift series.
    LinearLiftISVLDriver = 8;
    // Special Mode. Working purely as a can bus forwarder.
    PureForwardOnly = 100;
}

// Motor
message SingleMotorTarget{
    oneof target{
        double torque = 1;  // Nm
        double speed = 2;   // rad/s
        int64 position = 3; // encoder position
        bool brake = 4;     // No matter what mode, brake is always applied. Be aware that putting into brake mode might cause motor to lose position information.
    }
}

message MotorTargets {
    repeated SingleMotorTarget targets = 1;
}

enum MotorError{
    CommunicationError = 0;
    OverCurrent = 1;
    OverVoltage = 2;
    UnderVoltage = 3;
    MotorOverTemperature = 4;
    DriverOverTemperature = 5;
    GeneralError = 6;
}

message MotorStatus {
    // Nm
    double torque = 2; 
    // In general positivive is counter-clockwise(Right hand). But view angle is defined differently for different robot types.
    // View XSTD guide for detailed definition of positive direction.
    // m/s, direction is not defined, for linear motor
    double speed = 3;
    // encoder position
    int64 position = 4;
    // Number of pulses per rotation
    // Number of pulses per meter, for linear motor
    uint32 pulse_per_rotation = 5;
    double wheel_radius = 6;

    repeated MotorError error = 7;
    SingleMotorTarget current_target = 8;

    optional float driver_temperature = 11;
    optional float motor_temperature = 12;
    // current suppiled voltage
    optional float voltage = 13;
}

//////// Base //////////

// Base State
enum BaseState {
    BSParked = 0;
    BSAlgrithmControl = 1;
    BSOvertakeSpeedControl = 2;
    BSOvertakeZeroResistanceControl = 3;
    BSEmergencyStop = 4;
}

enum ParkingStopCategory {
    EmergencyStopButton = 0;
    MotorHasError = 1;
    BatteryFail = 2;
    GamepadTriggered = 3;
    UnknownParkingStopCategory = 4;
    APICommunicationTimeout = 5;
    LimitSwitchTriggered = 6;
}

message ParkingStopDetail {
    string reason = 1;
    ParkingStopCategory category = 2;
    bool is_remotely_clearable = 3;
}

enum WarningCategory {
    UnknownWarningCategory = 0;
    BatteryLow = 1;
}

message BaseStatus {
    BaseState state = 1;

    // Weather the API control is initialized.
    bool api_control_initialized = 2;
    float battery_voltage = 3;                  // V
    uint32 battery_thousandth = 4;              // 1/1000
    repeated MotorStatus motor_status = 5;

    optional bool battery_charging = 10;
    optional ParkingStopDetail parking_stop_detail = 11;
    optional WarningCategory warning = 12;
}

message EzBaseCommand {
    float spd_x = 1; // m/s
    float spd_y = 2; // m/s
    float spd_w = 3; // rad/s
}

message BaseCommand {
    oneof command{
        // Only after api_control_initialize is set, can the vehicle be controlled by the API.
        bool api_control_initialize = 1;
        // If currently has a clearable parking stop, the parking stop state will be cleared.
        bool clear_parking_stop = 2;

        // You have to continuesly send these commands no matter what if you want to use api control. (Start sending these commands and keep sending it first, then send api_control_initialize)
        // If you fail to do so, robot will stop.
        // Simplified base command. Might not be the best performance, but easy to use.
        EzBaseCommand ez_base_command = 3;
        // Control all motors directly. Do whatever you want.
        MotorTargets motor_targets = 4;
    }
}

//////// Lift //////////

enum LiftState {
    LSBrake = 0;
    LSCalibrating = 1;
    LSAlgrithmControl = 2;
    LSOvertakeControl = 3;
    LSEmergencyStop = 4;
}

// Read motor_status of APIUp to get current position
message LinearLiftStatus {
    bool calibrated = 1;
    LiftState state = 2;
    // The max position you can set using software.
    int64 max_pos = 3;
    int64 current_pos = 4;
    optional ParkingStopDetail parking_stop_detail = 10;
}

message LinearLiftCommand {
    oneof command{
        // No matter calibrate is true or false, will always start calibration when oneof selects this.
        bool calibrate = 1;
        // Encoder position.
        // You can calculate this from meters by multiplying with pulse_per_meter.
        // Do not send target_pos that larger than max_pos.
        // Unlike base, you don't have to keep sending this command.
        int64 target_pos = 2;
        // No matter brake is true or false, brake will be applied when oneof selects this.
        // If send other oneof, brake will be released.
        bool brake = 3;
    }
}
